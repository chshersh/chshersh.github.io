<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Comonadic builders</title>
    <meta name="author" content="Dmitrii Kovanikov">
    <meta name="description" content="Builder pattern in Haskell using Comonads">

    <link rel="stylesheet" href="/css/article.css">

    <!-- Metatags -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Dmitrii Kovanikov aka chshersh" />
    <meta property="og:title" content="Comonadic builders" />
    <meta property="og:description" content="Dmitrii Kovanikov's Personas Web Space" />
    <meta property="og:url" content="https://chshersh.com" />
    <meta property="og:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Comonadic builders" />
    <meta name="twitter:description" content="Builder pattern in Haskell using Comonads" />
    <meta name="twitter:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:image:src" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:url" content="https://chshersh.com" />

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
</head>
<body>
    <div id="imagePopup" class="popup-overlay">
        <img class="popup-image" id="popupImg" src="" alt="">
    </div>

    <header>
      <h1>Comonadic builders</h1>
    </header>

    <main>
<div class="home-button-container">
  <a href="/index.html" class="home-button"><strong>go ~to:Home</strong></a>
</div>

<p>When I was teaching advanced Haskell course to students, I‚Äôve created lab assignments on several compelling topics. One of the homework tasks on the comonad section is particularly interesting, and today I would like to share the problem itself with the solution and explanation. Turns out, you actually can use comonads to solve production problems from the real world.</p>
<h2 id="problem-statement">Problem statement</h2>
<p>The problem in its essence is simple ‚Äî we want to implement the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder programming pattern</a>. In simple words, the builder is used when you want to separate value creation from configuring the creation process. In our case, we can represent config as a separate data type, construct config first and only then create a value using the configuration.</p>
<blockquote>
<p><strong>NOTE:</strong> It is a known fact that comonads can help with representing some OOP patterns. Check out this blog post: <a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">OOP Comonads</a>.</p>
</blockquote>
<p>To make our problem entertaining, we want some of the configuration options to depend on the values of other options.</p>
<p>For example, let‚Äôs say you have a huge <code>Settings</code> data type that controls the properties of project scaffolding tool. This data type contains a lot of fields but there are dependencies between some of them. For example, you can specify flags whether you want <a href="http://github.com/">GitHub</a> or <a href="https://travis-ci.org/">Travis</a> integration enabled. However, if you disable GitHub integration, you shouldn‚Äôt be able to specify Travis integration because it doesn‚Äôt make sense to have it locally.</p>
<p>Of course, you can let users specify whatever they want and figure out fields dependencies later during value creation in one single place. However, there are reasons why this might not be desired:</p>
<ol type="1">
<li>If you have a lot of fields and a lot of dependencies, the code for tracking all these dependencies becomes messy really quickly.</li>
<li>It is a real pain to test such code.</li>
<li>It is difficult to refactor such code when you introduce a new field or dependency.</li>
</ol>
<p>So the question: can we do it better? The answer is yes and turns out that comonads provide a convenient and composable interface for this problem.</p>
<blockquote>
<p><strong>NOTE:</strong> The proposed solution has restrictions. It works only in a special case when dependencies have depth 1. In other words, your configuration contains two sets of options ‚Äî A and B ‚Äî and only options from set B depend on options from set A. Sure, it is possible to implement general solution with arbitrary non-cyclic dependencies (and maybe not with comonads) where you can disable and enable options, and all dependencies are resolved automatically. But I want to demonstrate how comonads can be used here and, who knows, maybe later this solution can be generalised!</p>
</blockquote>
<h2 id="short-intro-to-comonads">Short intro to comonads</h2>
<p>Before showing how comonads can be applied to solve the problem, I want to talk about the comonad concept itself. This is not a tutorial on comonads but I will try to give better intuition behind this typeclass.</p>
<h3 id="what-is-comonad">What is Comonad?</h3>
<p><code>Comonad</code> is implemented as the following typeclass available in the <a href="https://hackage.haskell.org/package/comonad">comonad</a> package:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">    extract   ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">    extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre></div>
<p>If you‚Äôre familiar with monads in Haskell, you may notice some similarities:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">    join   ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ot">    bind   ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>Basically the same thing, just with some arrows reversed. If <code>a</code> is a type of value, you can think of <code>w</code> and <code>m</code> as types of a context for that value. But there are some differences:</p>
<ol type="1">
<li><code>return</code> vs.¬†<code>extract</code>
<ul>
<li><code>return</code> knows how to attach context <code>m</code> to a value.</li>
<li><code>extract</code> always knows how to get value from the context <code>w</code>. In particular, this means that instances of the <code>Comonad</code> typeclass could be only for non-empty structures.</li>
</ul></li>
<li><code>join</code> vs.¬†<code>duplicate</code>
<ul>
<li><code>join</code> knows how to collapse contexts. This means, for example, that in most cases it doesn‚Äôt make sense to design interfaces around types like <code>Maybe (Maybe a)</code>, you can always get rid of nested contexts.</li>
<li><code>duplicate</code> can add one more layer of context if a value already has a context.</li>
</ul></li>
<li><code>bind</code> vs.¬†<code>extend</code>
<ul>
<li><code>bind</code> can change the resulting context <code>m</code> depending on a value inside the existing context. However, the function passed to <code>bind</code> is not allowed to analyze the current context, it can make decisions based on the value.</li>
<li><code>extend</code> takes a function that is allowed to analyze context <code>w</code> to produce a value of type <code>b</code>. However, the context itself remains unchanged.</li>
</ul></li>
</ol>
<p><code>Monad</code> doesn‚Äôt provide a generic way to get rid of a monadic context. Once you have entered a monad ‚Äî you always will be in the monad. You need to know specifics of your monad if you want to eliminate context from the value. However, monads provide a way to collapse multiple contexts into a single one using the <code>join</code> function.</p>
<p>With <code>Comonad</code> you always can extract the value from the comonadic context. But you need to know the internal structure of your data type to attach context in the first place. However, if you already have a context, you can add as many layers as you want using the <code>duplicate</code> function.</p>
<p>Before diving into more complicated stuff, let‚Äôs first look at the straightforward <code>Comonad</code> instance for a very innocent data type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Comonad</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">    extract ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    extract <span class="ot">=</span> runIdentity</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="ot">    duplicate ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> (<span class="dt">Identity</span> a)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    duplicate <span class="ot">=</span> <span class="dt">Identity</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="ot">    extend ::</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>    extend f <span class="ot">=</span> <span class="dt">Identity</span> <span class="op">.</span> f</span></code></pre></div>
<p>And who said that comonads are scary? :)</p>
<h3 id="arrow-comonad">Arrow comonad</h3>
<p>In order to implement the Builder pattern, we are going to use the <code>Comonad</code> instance for the function arrow <code>(-&gt;)</code>. The <code>comonad</code> package has the <a href="https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad-Trans-Traced.html#t:TracedT">Traced</a> <code>newtype</code> wrapper around the function <code>(-&gt;)</code>. The <code>Comonad</code> instance for this <code>newtype</code> gives us the desired behaviour.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Traced</span> m a <span class="ot">=</span> <span class="dt">Traced</span> {<span class="ot"> runTraced ::</span> m <span class="ot">-&gt;</span> a }</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Comonad</span> (<span class="dt">Traced</span> m)</span></code></pre></div>
<p>However, dealing with the <code>newtype</code> wrapping and unwrapping makes our code noisy and truly harder to understand, so let‚Äôs use the <code>Comonad</code> instance for the arrow <code>(-&gt;)</code> itself:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Comonad</span> ((<span class="ot">-&gt;</span>) m) <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">    extract ::</span> (m <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    extract f <span class="ot">=</span> f <span class="fu">mempty</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="ot">    duplicate ::</span> (m <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> a)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    duplicate f <span class="ot">=</span> \m1 m2 <span class="ot">-&gt;</span> f (m1 <span class="op">&lt;&gt;</span> m2)</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> there is no explicit implementation of the <code>extend</code> function since it has a default implementation via <code>duplicate</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>extend f <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> duplicate</span></code></pre></div>
<p>We are going to this definition later.</p>
</blockquote>
<p>I mentioned earlier that only non-empty structures can have a <code>Comonad</code> instance. In general case you can‚Äôt extract the value of type <code>a</code> using the function of type <code>m -&gt; a</code> without having <code>m</code>. However, if you know that the <code>m</code> is a <code>Monoid</code> then you always have <code>mempty</code> to pass to a function. <code>duplicate</code> is a no-brainer as well. If you have a function that takes a single value of type <code>m</code> and you need to make it work with two values of that type and you also know that <code>m</code> is a <code>Monoid</code> then it is easy ‚Äî just squash those two values with <code>mappend</code> and pass to your function.</p>
<p>We are going to use the <code>(-&gt;)</code> instance above as a fundamental piece of our interface in the following section.</p>
<h2 id="builder-pattern-using-comonad">Builder pattern using Comonad</h2>
<p>Finally, let‚Äôs solve the original problem! In Builder pattern we have several pieces:</p>
<ol type="1">
<li>A data type for the configuration.</li>
<li>A data type for the value created from the configuration.</li>
<li>A function that creates value from the configuration.</li>
<li>A way to compose builders.</li>
</ol>
<p>In our approach the <code>Builder</code> itself is a function that takes configuration and produces a value:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Builder</span> <span class="ot">=</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span></code></pre></div>
<p>And <code>Builder</code> is a comonad! However, it requires from <code>Config</code> to have the <code>Monoid</code> instance in order to make the whole thing work.</p>
<h3 id="monoidal-settings">Monoidal settings</h3>
<p>Let‚Äôs use a simpler version of the <code>Settings</code> data type in our example as the configuration. This data type has the following fields:</p>
<ol type="1">
<li>Flag that tells whether the project has a library or not (disabled by default).</li>
<li>Flag to enable GitHub integration (disabled by default).</li>
<li>Flag to enable Travis integration (disabled by default).</li>
</ol>
<p>In Haskell this can be represented as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Settings</span> <span class="ot">=</span> <span class="dt">Settings</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    {<span class="ot"> settingsHasLibrary ::</span> <span class="op">!</span><span class="dt">Any</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    ,<span class="ot"> settingsGitHub     ::</span> <span class="op">!</span><span class="dt">Any</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    ,<span class="ot"> settingsTravis     ::</span> <span class="op">!</span><span class="dt">Any</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>Here I‚Äôm using <code>Any</code> from the <code>Data.Semigroup</code> module. Since we need to have <code>Monoid</code> instance for <code>Settings</code>, let‚Äôs implement it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Settings</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="dt">Settings</span> a1 b1 c1 <span class="op">&lt;&gt;</span> <span class="dt">Settings</span> a2 b2 c2 <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>        <span class="dt">Settings</span> (a1 <span class="op">&lt;&gt;</span> a2) (b1 <span class="op">&lt;&gt;</span> b2) (c1 <span class="op">&lt;&gt;</span> c2)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Settings</span> <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Settings</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span></code></pre></div>
<h3 id="trivial-project-builder">Trivial project builder</h3>
<p>We are going to create <code>Project</code> from <code>Settings</code> and here is how our <code>Project</code> data type looks like:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Project</span> <span class="ot">=</span> <span class="dt">Project</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    {<span class="ot"> projectName       ::</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    ,<span class="ot"> projectHasLibrary ::</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    ,<span class="ot"> projectGitHub     ::</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    ,<span class="ot"> projectTravis     ::</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    }</span></code></pre></div>
<p>Finally, our Builder has the following type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ProjectBuilder</span> <span class="ot">=</span> <span class="dt">Settings</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span></code></pre></div>
<p>Trivial project builder just creates <code>Project</code> from <code>Settings</code> as it is:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">buildProject ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ProjectBuilder</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>buildProject projectName <span class="dt">Settings</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="dt">Project</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    { projectHasLibrary <span class="ot">=</span> getAny settingsHasLibrary</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    , projectGitHub     <span class="ot">=</span> getAny settingsGitHub</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    , projectTravis     <span class="ot">=</span> getAny settingsTravis</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    , <span class="op">..</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    }</span></code></pre></div>
<p>And you already can play with comonads:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;empty&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;empty&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    }</span></code></pre></div>
<h3 id="simple-project-builder">Simple project builder</h3>
<p>Now, what we would like to have, is a way to compose different builders. The idea here is to build the smallest and simplest project builders manually and create more complicated ones by composing the smaller ones. For this we are going to use the following operator from the <code>comonad</code> package:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">(=&gt;&gt;) ::</span> <span class="dt">Comonad</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>(<span class="op">=&gt;&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> extend</span></code></pre></div>
<p>When specialized to <code>ProjectBuilder</code>, it has the following type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">(=&gt;&gt;) ::</span> <span class="dt">ProjectBuilder</span> <span class="ot">-&gt;</span> (<span class="dt">ProjectBuilder</span> <span class="ot">-&gt;</span> <span class="dt">Project</span>) <span class="ot">-&gt;</span> <span class="dt">ProjectBuilder</span></span></code></pre></div>
<p>In order to see what it does, we can apply <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html">equational reasoning</a>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>builder <span class="op">=&gt;&gt;</span><span class="ot"> f ::</span> <span class="dt">Settings</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    <span class="co">-- (1) definition of (=&gt;&gt;)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="ot">=</span> <span class="fu">flip</span> extend builder f</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="co">-- (2) applying `flip`</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    <span class="ot">=</span> extend f builder</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="co">-- (3) default definition of `extend`</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    <span class="ot">=</span> (<span class="fu">fmap</span> f <span class="op">.</span> duplicate) builder</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>    <span class="co">-- (4) applying (.)</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>    <span class="ot">=</span> <span class="fu">fmap</span> f (duplicate builder)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>    <span class="co">-- (5) Using `duplicate` definition from Comonad instance for arrow</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>    <span class="ot">=</span> <span class="fu">fmap</span> f (\m1 m2 <span class="ot">-&gt;</span> builder (m1 <span class="op">&lt;&gt;</span> m2))</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>    <span class="co">-- (6) Using `fmap` definition from Functor instance for arrow</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>    <span class="ot">=</span> f <span class="op">.</span> (\m1 m2 <span class="ot">-&gt;</span> builder (m1 <span class="op">&lt;&gt;</span> m2))</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>    <span class="co">-- (7) eta-expanding outer lambda</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> (f <span class="op">.</span> (\m1 m2 <span class="ot">-&gt;</span> builder (m1 <span class="op">&lt;&gt;</span> m2)) settings</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>    <span class="co">-- (8) applying (.)</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> f <span class="op">$</span> (\m1 m2 <span class="ot">-&gt;</span> builder (m1 <span class="op">&lt;&gt;</span> m2)) settings</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true"></a>    <span class="co">-- (9) partially applying inner lambda</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> f <span class="op">$</span> \m2 <span class="ot">-&gt;</span> builder (settings <span class="op">&lt;&gt;</span> m2)</span></code></pre></div>
<p>But in order to understand, what <code>(=&gt;&gt;)</code> operator actually does, we need to think over its implementation for some time. What we achieved in the step (9) is the final form of the <code>(=&gt;&gt;)</code> operator and also the definition of the <code>extend</code> function from the <code>Comonad</code> typeclass for arrow <code>(-&gt;)</code>. Let‚Äôs first look at one example of the function <code>f</code> (can be passed as an argument to <code>(=&gt;&gt;)</code>).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">hasLibraryB ::</span> <span class="dt">ProjectBuilder</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>hasLibraryB builder <span class="ot">=</span> builder <span class="op">$</span> <span class="fu">mempty</span> { settingsHasLibrary <span class="ot">=</span> <span class="dt">Any</span> <span class="dt">True</span> }</span></code></pre></div>
<p><code>hasLibrary</code> builder needs to produce <code>Project</code>. This function takes an argument of type <code>builder :: Settings -&gt; Project</code> so the only way to return <code>Project</code> is to pass some <code>Settings</code> to <code>builder</code>. Here we pass <code>Settings</code> that just enable <code>hasLibrary</code> flag. But in general case, you can specify the context of arbitrary complexity for such functions so they can use smarter and more sophisticated logic.</p>
<p>By analogy we can create the builder for the GitHub flag:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">gitHubB ::</span> <span class="dt">ProjectBuilder</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>gitHubB builder <span class="ot">=</span> builder <span class="op">$</span> <span class="fu">mempty</span> { settingsGitHub <span class="ot">=</span> <span class="dt">Any</span> <span class="dt">True</span> }</span></code></pre></div>
<p>And you can see how it works:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;library&quot;</span> <span class="op">=&gt;&gt;</span> hasLibraryB</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;library&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;lib-git&quot;</span> <span class="op">=&gt;&gt;</span> hasLibraryB <span class="op">=&gt;&gt;</span> gitHubB</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;lib-git&quot;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>    }</span></code></pre></div>
<p>If you apply the equational reasoning technique here as well, you can see how all pieces combine together:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>buildProject <span class="st">&quot;foo&quot;</span> <span class="op">=&gt;&gt;</span><span class="ot"> hasLibraryB ::</span> <span class="dt">Settings</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> hasLibraryB <span class="op">$</span> \settings2 <span class="ot">-&gt;</span> buildProject <span class="st">&quot;foo&quot;</span> <span class="op">$</span> settings <span class="op">&lt;&gt;</span> settings2</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> (\settings2 <span class="ot">-&gt;</span> buildProject <span class="st">&quot;foo&quot;</span> <span class="op">$</span> settings <span class="op">&lt;&gt;</span> settings2) (<span class="fu">mempty</span> { settingsHasLibrary <span class="ot">=</span> <span class="dt">Any</span> <span class="dt">True</span> })</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    <span class="ot">=</span> \settings <span class="ot">-&gt;</span> buildProject <span class="st">&quot;foo&quot;</span> <span class="op">$</span> settings <span class="op">&lt;&gt;</span> <span class="fu">mempty</span> { settingsHasLibrary <span class="ot">=</span> <span class="dt">Any</span> <span class="dt">True</span> }</span></code></pre></div>
<h3 id="context-dependent-builders">Context-dependent builders</h3>
<p>Now comes the fun part. We need to implement a builder for the Travis flag. However, we can‚Äôt just do the same job that we did for the other flags. We don‚Äôt want to set <code>projectTravis</code> to <code>True</code> if GitHub flag is set to <code>False</code>. So we need to inspect the value of the GitHub flag before setting something to Travis flag. The way to achieve the desired behaviour is the following:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">travisB ::</span> <span class="dt">ProjectBuilder</span> <span class="ot">-&gt;</span> <span class="dt">Project</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>travisB builder <span class="ot">=</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="kw">let</span> project <span class="ot">=</span> extract builder</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>    <span class="kw">in</span> project { projectTravis <span class="ot">=</span> projectGitHub project }</span></code></pre></div>
<p>The key observation here: our initial <code>buildProject</code> function mappends all passed settings first and only then creates <code>Project</code>. So we can build the <code>Project</code> first and later perform post-analysis to decide how to set the flag.</p>
<blockquote>
<p><strong>NOTE:</strong> here <code>projectTravis</code> is set to the value of <code>projectGitHub</code> because it is the same as <code>if projectGitHub then True else False</code>.</p>
</blockquote>
<p>The neat thing about this approach is that the result doesn‚Äôt depend on the order of applied builders. Because of that, we have better composability:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;travis&quot;</span> <span class="op">=&gt;&gt;</span> travisB</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;travis&quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    }</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;github-travis&quot;</span> <span class="op">=&gt;&gt;</span> gitHubB <span class="op">=&gt;&gt;</span> travisB</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;github-travis&quot;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>    }</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>ghci<span class="op">&gt;</span> extract <span class="op">$</span> buildProject <span class="st">&quot;travis-github&quot;</span> <span class="op">=&gt;&gt;</span> travisB <span class="op">=&gt;&gt;</span> gitHubB</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a><span class="dt">Project</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>    { projectName <span class="ot">=</span> <span class="st">&quot;travis-github&quot;</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>    , projectHasLibrary <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a>    , projectGitHub <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a>    , projectTravis <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a>    }</span></code></pre></div>
<blockquote>
<p>To make sure that the above works you can apply the <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html">equational reasoning</a> technique here as well.</p>
</blockquote>
<h2 id="conclusion">Conclusion</h2>
<p>Putting all together we have the following pieces of the Builder pattern implemented in Haskell:</p>
<ol type="1">
<li><code>Settings</code>: our configuration which is a Monoid as well.</li>
<li><code>Project</code>: final result produced by our <code>Builder</code>.</li>
<li><code>type ProjectBuilder = Settings -&gt; Project</code>: our builder, also a Comonad.</li>
<li><code>extract</code>: a way to build <code>Project</code> from <code>Settings</code>.</li>
<li><code>(=&gt;&gt;)</code>: a way to compose different builders.</li>
</ol>
<p>I hope that this blog post gives you a better understanding of comonads and inspires you to play with them more!</p>
<p>Here is the gist with the complete code:</p>
<ul>
<li><a href="https://gist.github.com/ChShersh/5a4c8e1c0557627859fe93ad0b05dd56">Code sample for comonadic builders</a></li>
</ul>

<hr>
<blockquote>
<p>If you liked this blog post, consider supporting my work on GitHub Sponsors, or following me on the Internet:</p>
<ul>
<li><a target="_blank" href="https://github.com/sponsors/chshersh">GitHub Sponsors: @chshersh</a></li>
<li><a target="_blank" href="https://youtube.com/c/chshersh">YouTube: @chshersh</a></li>
<li><a target="_blank" href="https://x.com/ChShersh">ùïè: @chshersh</a></li>
<li><a target="_blank" href="https://bsky.app/profile/chshersh.com">BlueSky: @chshersh.com</a></li>
<li><a target="_blank" href="https://functional.cafe/@chshersh">Mastodon: functional.cafe@chshersh</a></li>
<li><a target="_blank" href="https://www.twitch.tv/chshersh">Twitch: @chshersh </a></li>
</ul>
</blockquote>
    </main>

<script src="/js/article.js"></script>

</body>
</html>
