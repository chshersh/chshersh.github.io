<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>7 OCaml Gotchas</title>
    <meta name="author" content="Dmitrii Kovanikov">
    <meta name="description" content="Surprising OCaml behaviours">

    <link rel="stylesheet" href="/css/article.css">

    <!-- Metatags -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Dmitrii Kovanikov aka chshersh" />
    <meta property="og:title" content="7 OCaml Gotchas" />
    <meta property="og:description" content="Dmitrii Kovanikov's Personas Web Space" />
    <meta property="og:url" content="https://chshersh.com" />
    <meta property="og:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="7 OCaml Gotchas" />
    <meta name="twitter:description" content="Surprising OCaml behaviours" />
    <meta name="twitter:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:image:src" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:url" content="https://chshersh.com" />

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
</head>
<body>
    <div id="imagePopup" class="popup-overlay">
        <img class="popup-image" id="popupImg" src="" alt="">
    </div>

    <header>
      <h1>7 OCaml Gotchas</h1>
    </header>

    <main>
<div class="home-button-container">
  <a href="/index.html" class="home-button"><strong>go ~to:Home</strong></a>
</div>

<p>Iâ€™ve been writing OCaml for about 1 year (check my previous post <a href="/blog/2023-12-16-8-months-of-ocaml-after-8-years-of-haskell.html">8 months of OCaml after 8 years of Haskell</a>).</p>
<p>I enjoy OCaml. But as any other programming language, OCaml has its quirks. Thatâ€™s fine, you can enjoy imperfect things too. But it could be useful to learn about potential surprising behaviours.</p>
<p>In this blog post, Iâ€™m highlighting <strong>7 OCaml gotchas</strong>. Some of them might be obvious to experienced OCamlers. But I hope everyone can learn something new or at least enjoy reading!</p>
<p>Letâ€™s start.</p>
<h2 id="structural-vs-physical-equality">1. Structural vs Physical equality</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ‘ğŸŒ‘</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>âš ï¸</td>
</tr>
</tbody>
</table>
<p>Being bitten by different types of equalities in a language like JavaScript, you exhale with relief when you learn that in OCaml you can easily compare numbers with <code>==</code> and it doesnâ€™t allow you to compare values of different types ğŸ˜®â€ğŸ’¨</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>utop # <span class="dv">255</span> == <span class="dv">255</span> ;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>utop # <span class="dv">0</span> == <span class="kw">false</span> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>Error: This expression has <span class="kw">type</span> <span class="dt">bool</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
<p>However, quite soon, with horror, you realise that <code>==</code> doesnâ€™t work with strings!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>utop # <span class="st">&quot;OCaml&quot;</span> == <span class="st">&quot;OCaml&quot;</span> ;;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
<p>Or with lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>utop # [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] == [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] ;;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
<p>Or with pairs</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>utop # (<span class="kw">true</span>, <span class="dv">1</span>) == (<span class="kw">true</span>, <span class="dv">1</span>) ;;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
<p>Or with optionals:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>utop # <span class="dt">Some</span> <span class="dv">10</span> == <span class="dt">Some</span> <span class="dv">10</span> ;;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
<p>Or literally with anything else!</p>
<p>Well, the thing is, OCaml has two equalities:</p>
<ul>
<li><code>=</code>: structural, actually compares values</li>
<li><code>==</code>: physical, compares pointers to values</li>
</ul>
<blockquote>
<p>As well as two inequalities, <code>&lt;&gt;</code> and <code>!=</code>. To figure out which one is physical and which is structural is left as an exercise for the reader.</p>
</blockquote>
<p>So, to actually check values for equality, use <code>=</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>utop # <span class="st">&quot;I Love OCaml&quot;</span> = <span class="st">&quot;I Love OCaml&quot;</span> ;;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span></code></pre></div>
<blockquote>
<p>And for the love of god, configure your linter to warn on usages of <code>==</code>. How many bugs has it causedâ€¦</p>
</blockquote>
<h2 id="nested-match-with">2. Nested <code>match-with</code></h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ—ğŸŒ‘ğŸŒ‘ğŸŒ‘</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>ğŸ¹</td>
</tr>
</tbody>
</table>
<p>Consider the following types:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">type</span> reason =</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  | Waiting</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  | Validating</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="kw">type</span> status =</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  | Pending <span class="kw">of</span> reason</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  | Cancelled</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  | Done</span></code></pre></div>
<p>Letâ€™s write a function to pattern match on a value of type <code>status</code> and convert the value to a string. We can use the <code>match-with</code> syntax in OCaml for this.</p>
<p>However, the following code doesnâ€™t compile!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">let</span> show_status status =</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="kw">match</span> status <span class="kw">with</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  | Pending reason -&gt;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="kw">match</span> reason <span class="kw">with</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    | Waiting -&gt; <span class="st">&quot;Pending: Waiting&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    | Validating -&gt; <span class="st">&quot;Pending: Validating&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  | Cancelled -&gt; <span class="st">&quot;Cancelled&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  | Done -&gt; <span class="st">&quot;Done&quot;</span></span></code></pre></div>
<p>The compilation error is:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>File <span class="st">&quot;lib/example.ml&quot;</span>, line <span class="dv">16</span>, characters <span class="dv">4-13</span>:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dv">16</span> |   | Cancelled -&gt; <span class="st">&quot;Cancelled&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>         ^^^^^^^^^</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>Error: This variant pattern is expected <span class="kw">to</span> have <span class="kw">type</span> reason</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>       There is no constructor Cancelled within <span class="kw">type</span> reason</span></code></pre></div>
<p>The explanation is that OCaml is not a layout-sensitive language ğŸ™…</p>
<p>When matching on <code>reason</code>, the compiler thinks that the <code>| Cancelled -&gt; ...</code> case is the next pattern, hence the error.</p>
<p>I know three fixes:</p>
<p><strong>1.</strong> Put <code>()</code> around the nested <code>match</code> explicitly</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">let</span> show_status status =</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="kw">match</span> status <span class="kw">with</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  | Pending reason -&gt;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    (<span class="kw">match</span> reason <span class="kw">with</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    | Waiting -&gt; <span class="st">&quot;Pending: Waiting&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    | Validating -&gt; <span class="st">&quot;Pending: Validating&quot;</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  | Cancelled -&gt; <span class="st">&quot;Cancelled&quot;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  | Done -&gt; <span class="st">&quot;Done&quot;</span></span></code></pre></div>
<p><strong>2.</strong> Move the only nested <code>match-with</code> to the end:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">let</span> show_status status =</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="kw">match</span> status <span class="kw">with</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  | Cancelled -&gt; <span class="st">&quot;Cancelled&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  | Done -&gt; <span class="st">&quot;Done&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  | Pending reason -&gt;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="kw">match</span> reason <span class="kw">with</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    | Waiting -&gt; <span class="st">&quot;Pending: Waiting&quot;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    | Validating -&gt; <span class="st">&quot;Pending: Validating&quot;</span></span></code></pre></div>
<p><strong>3.</strong> Extract nested <code>match-with</code> into a separate function</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">let</span> show_reason reason =</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="kw">match</span> reason <span class="kw">with</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  | Waiting -&gt; <span class="st">&quot;Pending: Waiting&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  | Validating -&gt; <span class="st">&quot;Pending: Validating&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">let</span> show_status status =</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  <span class="kw">match</span> status <span class="kw">with</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  | Pending reason -&gt; show_reason reason</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>  | Cancelled -&gt; <span class="st">&quot;Cancelled&quot;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  | Done -&gt; <span class="st">&quot;Done&quot;</span></span></code></pre></div>
<h2 id="labelled-and-optional-arguments">3. Labelled and Optional Arguments</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ‘ğŸŒ‘</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>ğŸ¹</td>
</tr>
</tbody>
</table>
<p>OCaml has labelled (aka named) and optional arguments.</p>
<p>However, if your function uses both labelled and optional arguments without positional arguments, you get a compiler error!</p>
<p>The following code implements a function that generates all numbers between the given two with an optional <code>step</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">let</span> range ?(step = <span class="dv">1</span>) ~from ~until =</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop i =</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="kw">if</span> i &gt; until</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>      <span class="kw">then</span> []</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>      <span class="kw">else</span> i :: loop (i + step)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  loop from</span></code></pre></div>
<p>Unfortunately, it doesnâ€™t compile!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>File <span class="st">&quot;lib/example.ml&quot;</span>, line <span class="dv">21</span>, characters <span class="dv">12-20</span>:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dv">21</span> | <span class="kw">let</span> range ?(step = <span class="dv">1</span>) ~from ~until =</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>                 ^^^^^^^^</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>Error (warning <span class="dv">16</span> [unerasable-optional-argument]):</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>this optional argument cannot be erased.</span></code></pre></div>
<p>The explanation is that you can specify both labelled and optional arguments in any order (you can mix and match):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>range ~step:<span class="dv">2</span> ~from:<span class="dv">10</span> ~until:<span class="dv">20</span>  <span class="co">(* this is valid *)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>range ~from:<span class="dv">10</span> ~until:<span class="dv">20</span> ~step:<span class="dv">2</span>  <span class="co">(* also valid! *)</span></span></code></pre></div>
<p>So when you call the <code>range</code> function like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>range ~from:<span class="dv">10</span> ~until:<span class="dv">20</span></span></code></pre></div>
<p>OCaml doesnâ€™t know whether you want to apply the default value of <code>step</code> or whether you want to have a partially applied <code>range</code> with only the default argument missing!</p>
<p>One of the solutions in this case is to add a positional argument of type <code>unit</code> at the end of the function, like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">let</span> range ?(step = <span class="dv">1</span>) ~from ~until () =</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop i =</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="kw">if</span> i &gt; until</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>      <span class="kw">then</span> []</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>      <span class="kw">else</span> i :: loop (i + step)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  loop from</span></code></pre></div>
<p>Alternatively, if it makes sense, you can convert one or more labelled arguments to positional to avoid adding an extra <code>unit</code>.</p>
<h2 id="type-inference-doesnt-work-well-part-1">4. Type inference doesnâ€™t work well: Part 1</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ—ğŸŒ‘</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>âš ï¸</td>
</tr>
</tbody>
</table>
<p>OCaml has type inference and it works even if you define your own custom types. Usually, it works pretty well.</p>
<p>Like in the example below, when we have a record type but we donâ€™t write explicit type annotations, OCaml is smart enough to figure out the types:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">type</span> book =</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  { author: <span class="dt">string</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    title: <span class="dt">string</span>;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    words: <span class="dt">int</span>;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  }</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="kw">let</span> is_novel book =</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>  book.words &gt;= <span class="dv">50000</span></span></code></pre></div>
<p>The OCaml compiler can easily infer the type of <code>is_novel</code> as</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">val</span> is_novel : book -&gt; <span class="dt">bool</span></span></code></pre></div>
<p>However, if you move the type definition into a separate module, OCaml gives up immediately:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">(* --- book.ml --- *)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="kw">type</span> book =</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>  { author: <span class="dt">string</span>;</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    title: <span class="dt">string</span>;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    words: <span class="dt">int</span>;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>  }</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="co">(* --- example.ml --- *)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="kw">let</span> is_novel book =</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  book.words &gt;= <span class="dv">50000</span></span></code></pre></div>
<p>The error message is:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>File <span class="st">&quot;lib/example.ml&quot;</span>, line <span class="dv">31</span>, characters <span class="dv">7-12</span>:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="dv">31</span> |   book.words &gt;= <span class="dv">50000</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>            ^^^^^</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>Error: Unbound record field words</span></code></pre></div>
<p>On one hand, it makes sense. Trying to guess the correct type across all possible modules and dependencies can decrease the compilation speed and introduce surprising behaviour.</p>
<p>However, this can be quite annoying when dealing with lots of types.</p>
<p>One solution is to specify the type explicitly in the inline type signature:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">let</span> is_novel (book : Book.book) =</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  book.words &gt;= <span class="dv">50000</span></span></code></pre></div>
<p>Alternatively, you can use the local open syntax:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">let</span> is_novel book =</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  Book.(book.words) &gt;= <span class="dv">50000</span></span></code></pre></div>
<h2 id="type-inference-doesnt-work-well-part-2">5. Type Inference doesnâ€™t work well: Part 2</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ‘</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>âš ï¸</td>
</tr>
</tbody>
</table>
<p>You want to write a function that creates a list by replicating the same element <code>n</code> times.</p>
<p>The implementation is straightforward:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">let</span> replicate n x = <span class="dt">List</span>.init n (<span class="kw">fun</span> _ -&gt; x)</span></code></pre></div>
<p>This function works and OCaml correctly infers the polymorphic type of <code>replicate</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">val</span> replicate : <span class="dt">int</span> -&gt; &#39;a -&gt; &#39;a <span class="dt">list</span></span></code></pre></div>
<p>Now, letâ€™s say we replicate numbers five times specifically a lot, and we want to create a helper function by partially applying <code>replicate</code> to <code>5</code> (honestly, itâ€™s easier to write the code than to explain it in English):</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">let</span> replicate_5 = replicate <span class="dv">5</span></span></code></pre></div>
<p>This function is partially applied only to the number, so youâ€™d still expect it to be polymorphic, right? Oh, boyâ€¦</p>
<p>Unfortunately, if you use <code>replicate_5</code> two times with different types, the OCaml compiler is not happy:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">let</span> two_lists =</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  <span class="kw">let</span> five_bools = replicate_5 <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  <span class="kw">let</span> five_ints = replicate_5 <span class="dv">21</span> <span class="kw">in</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>  (five_bools, five_ints)</span></code></pre></div>
<p>The error message is:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>File <span class="st">&quot;lib/example.ml&quot;</span>, line <span class="dv">42</span>, characters <span class="dv">30-32</span>:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="dv">42</span> |   <span class="kw">let</span> five_ints = replicate_5 <span class="dv">21</span> <span class="kw">in</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>                                   ^^</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>Error: This expression has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>         <span class="dt">bool</span></span></code></pre></div>
<p>You wonâ€™t believe what is the fix the problem.</p>
<p>The fix is to avoid partial application for polymorphic functions:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="kw">let</span> replicate_5 x = replicate <span class="dv">5</span> x</span></code></pre></div>
<p>Unfortunately, I know why itâ€™s done this way. OCaml has valid reasons for this behaviour, believe me (you can read on <a href="https://v2.ocaml.org/manual/polymorphism.html">Weak polymorphism</a>). Still, it makes me a bit annoyed.</p>
<h2 id="implicit-variable-quantification">6. Implicit variable quantification</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ•</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>ğŸ’€</td>
</tr>
</tbody>
</table>
<p>I want to write a function that takes an argument and returns it without changes. Again, the implementation is pretty simple:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">let</span> id x = x</span></code></pre></div>
<p>This function doesnâ€™t do anything specific, and OCaml correctly infers the polymorphic type:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">val</span> id : &#39;a -&gt; &#39;a</span></code></pre></div>
<p>I can write this function slightly differently by using an anonymous function:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">let</span> id = <span class="kw">fun</span> x -&gt; x</span></code></pre></div>
<p>And, if I want, I can even specify the inline type signature for the entire function</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">let</span> id : &#39;a -&gt; &#39;a = <span class="kw">fun</span> x -&gt; x</span></code></pre></div>
<blockquote>
<p>The example may look artificial, but sometimes I donâ€™t want to bother with creating a separate <code>.mli</code> file, and I want to have type signatures written explicitly</p>
</blockquote>
<p>What I can also do, is completely ignore the type signature and write any nonsense in my implementation:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">let</span> id : &#39;a -&gt; &#39;a = <span class="kw">fun</span> _ -&gt; <span class="dv">123</span></span></code></pre></div>
<p>And the compiler error will be.. Or, wait, thereâ€™s no error this time. OCaml is perfectly fine with this code ğŸ¥²</p>
<p>Turns out, if I really want to enforce the fact that the alpha <code>'a</code> indeed stands for a polymorphic variable, I need to introduce explicit quantification like this:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">let</span> id : &#39;a . &#39;a -&gt; &#39;a = <span class="kw">fun</span> x -&gt; x</span></code></pre></div>
<p>And with this, I can no longer write nonsense.</p>
<h2 id="right-to-left-order-of-execution">7. Right-to-left order of execution</h2>
<table>
<thead>
<tr class="header">
<th><strong>Property</strong></th>
<th><strong>Rating</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Surprise factor</td>
<td>ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ•ğŸŒ•</td>
</tr>
<tr class="even">
<td>Severity</td>
<td>ğŸ¹</td>
</tr>
</tbody>
</table>
<p>If you want to write a function that takes two actions and runs them sequentially, like this one:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">let</span> (&gt;&gt;) action1 action2 = action1; action2</span></code></pre></div>
<p>And then you want to use it:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="kw">let</span> run_example () =</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>  <span class="dt">print_endline</span> <span class="st">&quot;Hello, &quot;</span> &gt;&gt; <span class="dt">print_endline</span> <span class="st">&quot;World&quot;</span></span></code></pre></div>
<p>Youâ€™ll be surprised by the actual behaviour:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>utop # run_example () ;;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>World</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>Hello,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
<p>Apparently, OCaml evaluates arguments from right to left, so the second argument is evaluated first.</p>
<blockquote>
<p>In fact, the order of evaluation is not even guaranteed.</p>
</blockquote>
<p>The only solution is to avoid relying on this behaviour. Make your functions accept arguments of type <code>unit -&gt; ...</code> or <code>Lazy.t</code>, so the functions can control the execution order of their arguments.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Thatâ€™s all! If you found anything surprising in OCaml, feel free to share!</p>
<p>As I mentioned, every language has some pitfalls. If you donâ€™t see them in your favourite language, you either donâ€™t know it well enough or nobody uses this language anymore.</p>
<p>Human brains are really good at focusing on bad things. However, I wrote this blog post not to say that OCaml is bad but rather to reduce the frustration when experiencing something surprising for the first time ğŸ˜Œ</p>

<hr>
<blockquote>
<p>If you liked this blog post, consider supporting my work on GitHub Sponsors, or following me on the Internet:</p>
<ul>
<li><a target="_blank" href="https://github.com/sponsors/chshersh">GitHub Sponsors: @chshersh</a></li>
<li><a target="_blank" href="https://youtube.com/c/chshersh">YouTube: @chshersh</a></li>
<li><a target="_blank" href="https://x.com/ChShersh">ğ•: @chshersh</a></li>
<li><a target="_blank" href="https://bsky.app/profile/chshersh.com">BlueSky: @chshersh</a></li>
<li><a target="_blank" href="https://functional.cafe/@chshersh">Mastodon: functional.cafe@chshersh</a></li>
<li><a target="_blank" href="https://www.twitch.tv/chshersh">Twitch: @chshersh </a></li>
</ul>
</blockquote>
    </main>

    <script>
        const popup = document.getElementById('imagePopup');
        const popupImg = document.getElementById('popupImg');

        document.querySelectorAll('main img:not(.popup-image)').forEach(img => {
            img.addEventListener('click', function() {
                popup.style.display = 'block';
                popupImg.src = this.src;
                document.body.style.overflow = 'hidden';
            });
        });


        popup.addEventListener('click', function(e) {
            if (e.target === popup) {
                popup.style.display = 'none';
                document.body.style.overflow = ''; 
            }
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && popup.style.display === 'block') {
                popup.style.display = 'none';
                document.body.style.overflow = ''; 
            }
        });
    </script>
</body>
</html>
