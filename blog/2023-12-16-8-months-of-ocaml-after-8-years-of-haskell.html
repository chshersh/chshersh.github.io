<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>8 months of OCaml after 8 years of Haskell in production</title>
    <meta name="author" content="Dmitrii Kovanikov">
    <meta name="description" content="Comparing my experience in OCaml with Haskell">

    <link rel="stylesheet" href="/css/article.css">

    <!-- Metatags -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Dmitrii Kovanikov aka chshersh" />
    <meta property="og:title" content="8 months of OCaml after 8 years of Haskell in production" />
    <meta property="og:description" content="Dmitrii Kovanikov's Personas Web Space" />
    <meta property="og:url" content="https://chshersh.com" />
    <meta property="og:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="8 months of OCaml after 8 years of Haskell in production" />
    <meta name="twitter:description" content="Comparing my experience in OCaml with Haskell" />
    <meta name="twitter:image" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:image:src" content="https://chshersh.com/images/logo.jpg" />
    <meta name="twitter:url" content="https://chshersh.com" />

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
</head>
<body>
    <div id="imagePopup" class="popup-overlay">
        <img class="popup-image" id="popupImg" src="" alt="">
    </div>

    <header>
      <h1>8 months of OCaml after 8 years of Haskell in production</h1>
    </header>

    <main>
<div class="home-button-container">
  <a href="/index.html" class="home-button"><strong>go ~to:Home</strong></a>
</div>

<p>Iâ€™ve been using Haskell in production for 8 years. Iâ€™ve been using OCaml in production for 8 months.</p>
<p>Itâ€™s time to compare those two languages.</p>
<h1 id="syntax">Syntax</h1>
<p>Haskell probably has the most elegant syntax across all languages Iâ€™ve seen (maybe Idris is better because dependently typed code can become ugly in Haskell really quickly).</p>
<p>Thereâ€™s utter joy in expressing your ideas by typing as few characters as possible.</p>
<p>OCaml, being a language from the ML family is great too, but still, Haskell is more tacit.</p>
<p>Compare a few examples:</p>
<h2 id="sum-of-all-numbers-in-a-string">Sum of all numbers in a string</h2>
<blockquote>
<p>Using just the standard library</p>
</blockquote>
<p><strong>Haskell</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- strSum &quot;100  -42 15&quot; = 73</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">strSum ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>strSum <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">read</span> <span class="op">.</span> <span class="fu">words</span></span></code></pre></div>
<p><strong>OCaml</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">(* str_sum &quot;100  -42 15&quot; = 73 *)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">let</span> str_sum (str: <span class="dt">string</span>): <span class="dt">int</span> =</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  str</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  |&gt; <span class="dt">String</span>.split_on_char <span class="ch">&#39; &#39;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  |&gt; <span class="dt">List</span>.filter_map int_of_string_opt</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  |&gt; <span class="dt">List</span>.fold_left (+) <span class="dv">0</span></span></code></pre></div>
<h2 id="defining-a-new-binary-tree-type">Defining a new binary tree type</h2>
<p><strong>Haskell</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Leaf</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span></code></pre></div>
<p><strong>OCaml</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  | Leaf</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  | Node <span class="kw">of</span> &#39;a * &#39;a tree * &#39;a tree</span></code></pre></div>
<h2 id="parsing">Parsing</h2>
<blockquote>
<p>Return the result on successful parsing of lines like the one below where â€œStatusâ€ equals to zero and the result is an even number</p>
<pre><code>&quot;Status: -1 | Result: 42&quot;</code></pre>
</blockquote>
<p><strong>Haskell</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>parseLine line <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    [<span class="st">&quot;Status:&quot;</span>, <span class="st">&quot;0&quot;</span>, _, <span class="st">&quot;Result:&quot;</span>, result] <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="op">$</span> <span class="fu">words</span> line</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    n <span class="ot">&lt;-</span> readMaybe result</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    guard <span class="op">$</span> <span class="fu">even</span> n</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="fu">pure</span> n</span></code></pre></div>
<p><strong>OCaml</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">let</span> parse_line (line: <span class="dt">string</span>): <span class="dt">int</span> <span class="dt">option</span> =</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="kw">let</span> ( <span class="kw">let</span>* ) = Option.bind <span class="kw">in</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="kw">let</span>* result =</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">match</span> <span class="dt">String</span>.split_on_char <span class="ch">&#39; &#39;</span> line <span class="kw">with</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    | [<span class="st">&quot;Status:&quot;</span>; <span class="st">&quot;0&quot;</span>; _; <span class="st">&quot;Result:&quot;</span>; result] -&gt; <span class="dt">Some</span> result</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    | _ -&gt; <span class="dt">None</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  <span class="kw">let</span>* n = int_of_string_opt result <span class="kw">in</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  <span class="kw">if</span> n <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Some</span> n <span class="kw">else</span> <span class="dt">None</span></span></code></pre></div>
<hr/>
<p>The above are just a few random code snippets. They donâ€™t give an idea of all possible programs that could be written in those languages. But I hope they can quickly highlight the similarities and differences between the two languages.</p>
<p>This slowly leads us to the next point.</p>
<h1 id="features">Features</h1>
<p>Haskell has waaaaaay more features than probably any other programming language (well, C++ can compete). This is both good and bad.</p>
<p>Itâ€™s good because you have the tools to solve your problems in the best way.</p>
<p>Itâ€™s bad because you have those tools. Theyâ€™re distracting. Every time I need to solve a problem in Haskell, Iâ€™m immediately thinking about all the ways I can design the solution instead of, ahem, actually implementing this solution.</p>
<p>Iâ€™m interested in building stuff, not sitting near my pond on a warm summer day, thinking if TypeFamilies + DataKinds would be better than GADTs for making illegal states unrepresentable.</p>
<p>If I come to an existing OCaml project, the worst thing previous developers could do to it is have poor variable names, minimal documentation, and 200+ LOC functions. Thatâ€™s fine, nothing extraordinary, I can handle that.</p>
<p>If I come to an existing Haskell project, the worst thing previous developers could doâ€¦ Well, my previous 8 years of Haskell experience canâ€™t prepare me for that ğŸ˜…</p>
<p>Thatâ€™s why I feel more productive in OCaml.</p>
<p>I do miss some Haskell features at times. But Iâ€™ve seen their ugly side and what they can do to your output.</p>
<p>Consider the following table with a full comparison of major features.</p>
<h3 id="feature-comparison-table">Feature comparison table</h3>
<table>
<thead>
<tr class="header">
<th><strong>Feature</strong></th>
<th><strong>OCaml</strong></th>
<th><strong>Haskell</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expression-oriented syntax</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Immutability by default</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Higher-Order Functions (HOFs)</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Anonymous functions (lambdas)</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Algebraic Data Types (ADTs)</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Pattern Matching</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Parametric Polymorphism</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Type Inference</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Monadic Syntax Sugar</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Garbage Collector</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Multithreading</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>GADTs</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Purity by default</td>
<td>âŒ</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Composable laziness</td>
<td>âŒ</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Type classes</td>
<td>âŒ</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>Higher-Kinded Types</td>
<td>âŒ</td>
<td>âœ…</td>
</tr>
<tr class="odd">
<td>Opt-in language features</td>
<td>âŒ</td>
<td>âœ…</td>
</tr>
<tr class="even">
<td>First-class modules</td>
<td>âœ…</td>
<td>âŒ</td>
</tr>
<tr class="odd">
<td>Polymorphic variants</td>
<td>âœ…</td>
<td>âŒ</td>
</tr>
<tr class="even">
<td>Objects</td>
<td>âœ…</td>
<td>âŒ</td>
</tr>
<tr class="odd">
<td>Classes and Inheritance</td>
<td>âœ…</td>
<td>âŒ</td>
</tr>
<tr class="even">
<td>Ergonomic mutability</td>
<td>âœ…</td>
<td>âŒ</td>
</tr>
</tbody>
</table>
<h1 id="ecosystem">Ecosystem</h1>
<p>Letâ€™s be honest, both programming languages are niche FP langs. So you shouldnâ€™t expect first-class support for the latest modern framework that just got published.</p>
<p>However, in my experience, despite needing to write more custom bindings, you have solutions for the majority of common tasks.</p>
<p>For example, in OCaml, you can find:</p>
<ul>
<li><a href="https://github.com/dmbaturin/otoml/">otoml: A TOML parser</a></li>
<li><a href="https://github.com/leostera/minttea">Mint Tea: A TUI framework</a></li>
<li><a href="https://github.com/imandra-ai/ocaml-opentelemetry">ocaml-opentelemetry: Instrumentation for OpenTelemetry</a></li>
<li><a href="https://github.com/solvuu/awsm">awsm: OCaml AWS Client</a></li>
<li><a href="https://github.com/gopiandcode/petrol">petrol: An OCaml SQL API made to go FAST</a></li>
</ul>
<p>And so on. Similar story for Haskell.</p>
<p>Iâ€™d still say that the Haskell ecosystem has more packages and more ready-to-go solutions.</p>
<p>Itâ€™s easy to show the difference in the following example.</p>
<p>Number of <a href="https://stripe.com/docs/api">Stripe API</a> client libraries:</p>
<ul>
<li>Haskell: 13</li>
<li>OCaml: 1 (last change was 8 years ago, so itâ€™s more like zero)</li>
</ul>
<p>You may find a solution in Haskell. But often youâ€™ll discover <strong>too many</strong> solutions, you wonâ€™t know which one to choose.</p>
<p>Choosing a library in Haskell becomes a separate skill you need to master. Haskellers <a href="https://www.haskellforall.com/2018/05/how-i-evaluate-haskell-packages.html">even blog their recommendations</a> on how to choose a library! And youâ€™ll face this dilemma over and over again.</p>
<p>Often, a new Haskell library is created not because it solves a different problem.</p>
<p>But because the author wanted to <em>write it differently</em> (using different abstractions, playing with new features, etc. Who doesnâ€™t want a new streaming library based on LinearTypes???).</p>
<p>Itâ€™s not exciting to write a GitHub API client and parse tons of JSON.</p>
<p>But it is exciting to design a <a href="https://www.youtube.com/watch?v=elqPlMyryjc">logger with comonads</a>.</p>
<h1 id="tooling">Tooling</h1>
<p>The Haskell tooling evokes the most controversial feelings. Itâ€™s like an emotional roller coaster:</p>
<ul>
<li>ğŸ¤© Hoogle is the best! I can search through the entire ecosystem by using just a type signature!!!</li>
<li>ğŸ˜¨ Wait, why build tooling error messages are so bad, what do you mean it couldnâ€™t find a build plan for a working project???</li>
<li>ğŸ¤© Global content-addressable storage for all dependencies is such an amazing idea!!!</li>
<li>ğŸ˜¨ What do you mean I need to recompile my IDE because I changed my package???</li>
<li>ğŸ¤© I can automatically test all the code snippets in my package docs!!!</li>
<li>ğŸ˜¨ Wait, why doesnâ€™t the standard library have docs at all for this version I use???</li>
</ul>
<p>And so on.</p>
<p>Using Haskell tooling is like always being in the quantum superposition of <strong>â€œHow do you even use other PLs without such wholesome Haskell tools???â€</strong> and <strong>â€œHow can Haskellers live like that without these usability essentials???â€</strong>.</p>
<hr/>
<p>OCaml, on the other hand, hits differently. Because its ecosystem is smaller, you actually get surprised every time you find something working!</p>
<p>For example, the VSCode plugin for OCaml based on Language Server Protocol (LSP) works out-of-the-box. I never had any issues with it. It <strong>just works</strong> â„¢ï¸</p>
<p>The ergonomics of starting with OCaml tooling might not be the best but theyâ€™re straightforward and robust. And they work most of the time.</p>
<hr/>
<p>To get a full picture, refer to the following table for the full comparison of available tooling in both languages.</p>
<h3 id="tooling-comparison-table">Tooling comparison table</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 26%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Tool</strong></th>
<th><strong>OCaml</strong></th>
<th><strong>Haskell</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compiler</td>
<td><a href="https://github.com/ocaml/ocaml">ocaml</a></td>
<td><a href="https://gitlab.haskell.org/ghc/ghc">ghc</a></td>
</tr>
<tr class="even">
<td>REPL</td>
<td><a href="https://github.com/ocaml-community/utop">utop</a></td>
<td><a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html">ghci</a></td>
</tr>
<tr class="odd">
<td>Build tool</td>
<td><a href="https://dune.build/">dune</a></td>
<td><a href="https://cabal.readthedocs.io/en/latest/">cabal</a>, <a href="https://docs.haskellstack.org/en/stable/">stack</a></td>
</tr>
<tr class="even">
<td>Package manager</td>
<td><a href="https://opam.ocaml.org/">opam</a></td>
<td><a href="https://cabal.readthedocs.io/en/latest/">cabal</a></td>
</tr>
<tr class="odd">
<td>Package repository</td>
<td><a href="https://opam.ocaml.org/">opam</a></td>
<td><a href="https://hackage.haskell.org/">Hackage</a></td>
</tr>
<tr class="even">
<td>Toolchain installer</td>
<td>-</td>
<td><a href="https://www.haskell.org/ghcup/">ghcup</a></td>
</tr>
<tr class="odd">
<td>Linter</td>
<td><a href="https://github.com/Kakadu/zanuda">zanuda</a></td>
<td><a href="https://github.com/ndmitchell/hlint">hlint</a></td>
</tr>
<tr class="even">
<td>Formatter</td>
<td><a href="https://github.com/ocaml-ppx/ocamlformat">ocamlformat</a>, <a href="https://github.com/tweag/topiary">topiary</a></td>
<td><a href="https://fourmolu.github.io/">fourmolu</a>, <a href="https://github.com/haskell/stylish-haskell">stylish-haskell</a>, <a href="https://github.com/mihaimaruseac/hindent">hindent</a>, <a href="https://github.com/tweag/ormolu">ormolu</a></td>
</tr>
<tr class="odd">
<td>Type Search</td>
<td><a href="https://doc.sherlocode.com/">Sherlodoc</a></td>
<td><a href="https://hoogle.haskell.org/">Hoogle</a></td>
</tr>
<tr class="even">
<td>Code search</td>
<td><a href="https://sherlocode.com/">Sherlocode</a></td>
<td><a href="https://hackage-search.serokell.io/">Hackage Search</a></td>
</tr>
<tr class="odd">
<td>Online playground</td>
<td><a href="https://try.ocamlpro.com/">TryOCaml</a></td>
<td><a href="https://play.haskell.org/">Haskell Playground</a></td>
</tr>
<tr class="even">
<td>LSP</td>
<td><a href="https://github.com/ocaml/ocaml-lsp">ocaml-lsp</a></td>
<td><a href="https://github.com/haskell/haskell-language-server">HLS</a></td>
</tr>
</tbody>
</table>
<h1 id="compiler-messages">Compiler messages</h1>
<p>I want to highlight the compiler aspect of tooling separately since this is the tool you interact the most with.</p>
<p>Especially, compiler suggestions.</p>
<p>When using FP languages, the compiler is your best friend! You rely on it heavily to understand why your assumptions havenâ€™t been codified precisely.</p>
<p>Therefore, the compiler must present the information in the most accessible way.</p>
<p>In my view, Haskell compiler messages tend to be verbose with lots of contextual, often redundant, and distracting information.</p>
<p>OCaml compiler messages, on the other hand, are quite succinct. Sometimes too succinct.</p>
<p>Consider the following example.</p>
<h2 id="haskell-compiler-messages-example">Haskell: Compiler messages example</h2>
<p><strong>Program with an error</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span></code></pre></div>
<p><strong>Compiler output</strong></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kh45ype7j5lo9gns76d7.png" alt="" /><figcaption>Haskell Compiler Error Message</figcaption>
</figure>
<h2 id="ocaml-compiler-messages-example">OCaml: Compiler messages example</h2>
<p><strong>Program with an error</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">let</span> x = <span class="dv">1</span> + [<span class="dv">3</span>; <span class="dv">1</span>; <span class="dv">2</span>]</span></code></pre></div>
<p><strong>Compiler output</strong></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/t44lbbjywfvpj3d4gnv4.png" alt="" /><figcaption>OCaml Compiler Error Message</figcaption>
</figure>
<hr/>
<p>This is just one example (and most likely not the best one), but you can already see the differences in how information is presented and how types work in different languages.</p>
<h1 id="standard-library">Standard library</h1>
<p>I believe the standard library deserves a separate mention too.</p>
<p>It shapes your first program in a language and guides you through all future journeys.</p>
<p>A great standard library is a cornerstone of your PL success.</p>
<p>A poor standard library is a cornerstone of never-ending bikesheds about a better standard library (including an endless variety of alternative competing standard libraries).</p>
<p>Iâ€™m a big proponent of the idea that a standard library should be batteries-included.</p>
<p>Give me an Option-like type, a UTF-8 string, Map and HashMap, JSON and XML parsers, async primitives, and so on, so I can avoid learning your poor implementation of dependency tracking and build tooling. (<a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf">Build Systems a la Carte</a> is a thorough analysis of the space of dependency trackers and build tools.).</p>
<p>Both Haskell and OCaml have kinda barebones standard libraries. They have minor differences (e.g.Â Haskell doesnâ€™t include Map and HashMap; OCaml doesnâ€™t have non-empty lists and Bitraversable). But overall theyâ€™re similar in the spirit.</p>
<p>The Haskell standard library is called <code>base</code> and OCaml standard library is called.. well, itâ€™s just â€œthe standard libraryâ€.</p>
<ul>
<li><a href="https://hackage.haskell.org/package/base">base: The Haskell Standard Library</a></li>
<li><a href="https://v2.ocaml.org/api/index.html">OCaml: The standard library</a></li>
</ul>
<p>However, one difference is striking. The quality of Haskell documentation sometimes can amaze even a seasoned developer.</p>
<blockquote>
<p>Haskell has a few more nice features, like the ability to jump to sources from docs but Iâ€™ve been told such features are being cooked for OCaml too ğŸ‘€</p>
</blockquote>
<p>Compare a few doc snippets for the List data type (one of the fundamental structures in FP):</p>
<p><strong>Haskell</strong></p>
<p><a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List.html#v:head">Haskell: Data.List.head</a></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j38mezm8mld79emi3me9.png" alt="" /><figcaption>Haskell head</figcaption>
</figure>
<p><a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List.html#v:-33--63-">Haskell: !?</a></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/chphke0bux2l3fq0x93y.png" alt="" /><figcaption>Haskell index</figcaption>
</figure>
<p><strong>OCaml</strong></p>
<p><a href="https://v2.ocaml.org/api/List.html">OCaml: List.hd</a></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7cmzh4pd66kmgpav9xl.png" alt="" /><figcaption>OCaml hd</figcaption>
</figure>
<p><a href="https://v2.ocaml.org/api/List.html">OCaml: List.nth_opt</a></p>
<figure>
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mvn0bo84lbf6pibvbq7l.png" alt="" /><figcaption>OCaml nth_opt</figcaption>
</figure>
<hr/>
<p>You may argue that the result of such functions is obvious, therefore thereâ€™s no need to write essays under each function.</p>
<p>Iâ€™m a fan of example-driven documentation, and I love seeing usage examples in docs! This immediately gives me an idea of how I can leverage the API in the best way.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I want to end this blog post by saying:</p>
<p><strong>Both languages came a long way to support real industrial needs.</strong></p>
<p>Theyâ€™re still small compared to mainstream languages.</p>
<p>If youâ€™re not critically dependent on the presence of some specific SDK, you can choose any and have lots of joy while coding your next app ğŸ§¡</p>
<p>However, I prefer OCaml nowadays because I feel that I can focus on actually building stuff with this language.</p>
<h1 id="discussions">Discussions</h1>
<p>Besides the comment section below, you can also find the discussions of this blog post in various places:</p>
<ul>
<li><a href="https://twitter.com/ChShersh/status/1740303405678006422">ğ• by chshersh</a> (210+ ğŸ§¡, 14+ comments)</li>
<li><a href="https://news.ycombinator.com/item?id=42302426">Hacker News</a> (264+ points, 277+ comments)</li>
<li><a href="https://discuss.ocaml.org/t/8-months-of-ocaml-after-8-years-of-haskell-in-production/13729">OCaml Discuss</a> (16+ ğŸ§¡, 16+ comments)</li>
<li><a href="https://discourse.haskell.org/t/8-months-of-ocaml-after-8-years-of-haskell-in-production/8405">Haskell Discourse</a> (27+ ğŸ§¡, 107+ comments)</li>
<li><a href="https://lobste.rs/s/0xsnfj/8_months_ocaml_after_8_years_haskell">Lobste.rs: ml</a> (39+ â¬†ï¸, 16+ comments)</li>
<li><a href="https://www.reddit.com/r/ocaml/comments/18sq1p5/8_months_of_ocaml_after_8_years_of_haskell_in/">Reddit: /r/ocaml</a> (22+ â¬†ï¸, 18+ comments)</li>
<li><a href="https://www.reddit.com/r/haskell/comments/18sq4gp/8_months_of_ocaml_after_8_years_of_haskell_in/">Reddit: /r/haskell</a> (91+ â¬†ï¸, 57+ comments)</li>
</ul>

<hr>
<blockquote>
<p>If you liked this blog post, consider supporting my work on GitHub Sponsors, or following me on the Internet:</p>
<ul>
<li><a target="_blank" href="https://github.com/sponsors/chshersh">GitHub Sponsors: @chshersh</a></li>
<li><a target="_blank" href="https://youtube.com/c/chshersh">YouTube: @chshersh</a></li>
<li><a target="_blank" href="https://x.com/ChShersh">ğ•: @chshersh</a></li>
<li><a target="_blank" href="https://bsky.app/profile/chshersh.com">BlueSky: @chshersh</a></li>
<li><a target="_blank" href="https://functional.cafe/@chshersh">Mastodon: functional.cafe@chshersh</a></li>
<li><a target="_blank" href="https://www.twitch.tv/chshersh">Twitch: @chshersh </a></li>
</ul>
</blockquote>
    </main>

    <script>
        const popup = document.getElementById('imagePopup');
        const popupImg = document.getElementById('popupImg');

        document.querySelectorAll('main img:not(.popup-image)').forEach(img => {
            img.addEventListener('click', function() {
                popup.style.display = 'block';
                popupImg.src = this.src;
                document.body.style.overflow = 'hidden';
            });
        });


        popup.addEventListener('click', function(e) {
            if (e.target === popup) {
                popup.style.display = 'none';
                document.body.style.overflow = ''; 
            }
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && popup.style.display === 'block') {
                popup.style.display = 'none';
                document.body.style.overflow = ''; 
            }
        });
    </script>
</body>
</html>
