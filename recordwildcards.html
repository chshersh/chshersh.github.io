<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135017265-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-135017265-1');
    </script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Personal website and some blog posts">
  <meta name="author" content="Dmitrii Kovanikov">

  <title>The Power of RecordWildCards</title>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">

  <!-- Custom styles for this template -->
  <link href="./css/resume.css" rel="stylesheet">
  <link href="./css/dracula.css" rel="stylesheet">
  <link href="./css/post.css" rel="stylesheet">

  <!-- Metatags -->
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="kodimensional by Dmitrii Kovanikov" />
  <meta property="og:title" content="kodimensional :: The Power of RecordWildCards" />
  <meta property="og:description" content="Best-practices for the RecordWildCards language extension" />
  <meta property="og:url" content="https://chshersh.github.io" />
  <meta property="og:image" content="/images/logo-yellow.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="kodimensional :: The Power of RecordWildCards" />
  <meta name="twitter:description" content="Best-practices for the RecordWildCards language extension" />
  <meta name="twitter:image:src" content="https://chshersh.github.io/images/logo-yellow.png" />
  <meta name="twitter:url" content="https://chshersh.github.io" />

  <!-- Favicon -->
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="./images/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="./images/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="./images/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="./images/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="./images/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="./images/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="./images/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="./images/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="./images/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./images/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./images/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="./images/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./images/icons/favicon-16x16.png">
  <link rel="manifest" href="./images/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary" id="sideNav">
    <h2 class="mb-0 blog-name text-uppercase"><span class="text-white">ko</span>dimensional</h2>
    <p class="text-black d-lg-block d-none">by Dmitrii Kovanikov</p>

    <a class="navbar-brand js-scroll-trigger" href="./">
      <span class="d-block d-lg-none">Dmitrii Kovanikov</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="./#about">λ &rarr; ABOUT</a>
        </li>
        <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="./#experience">λ &rarr; EXPERIENCE</a>
        </li>
        <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="./#projects">λ &rarr; PROJECTS</a>
        </li>
        <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="./#blog">λ &rarr; BLOG</a>
        </li>
      </ul>

    </div>

    <div class="social-icons row justify-content-center">
      <iframe src="https://github.com/sponsors/chshersh/button" title="Sponsor chshersh" height="35" width="50%" style="border: 0;"></iframe>
    </div>

    <div class="social-icons row justify-content-center">
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://twitter.com/chshersh" target="_blank">
              <i class="fab fa-twitter"></i>
          </a>
        </div>
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://github.com/chshersh" target="_blank">
              <i class="fab fa-github"></i>
          </a>
        </div>
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://www.reddit.com/user/chshersh" target="_blank">
              <i class="fab fa-reddit"></i>
          </a>
        </div>
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://stackoverflow.com/users/2900502/shersh" target="_blank">
              <i class="fab fa-stack-overflow"></i>
          </a>
        </div>
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://www.linkedin.com/in/chshersh/" target="_blank">
              <i class="fab fa-linkedin"></i>
          </a>
        </div>
        
        <div class="col-2 col-lg-4 py-1">
          <a href="https://t.me/chshersh" target="_blank">
              <i class="fab fa-telegram"></i>
          </a>
        </div>
        
    </div>

  </nav>

  <div class="container-fluid p-0">

      <section class="resume-section p-3 p-lg-5">
        <h2 class="text-center">The Power of RecordWildCards</h2>
        <p class="text-center text-black">July 29, 2019</p>

        <div class="col-12 tag-block text-center">
            
            <span class="post-tag"><a class="btn btn-outline-warning">haskell</a></span>
            
            <span class="post-tag"><a class="btn btn-outline-warning">syntax</a></span>
            
            <span class="post-tag"><a class="btn btn-outline-warning">language</a></span>
            
            <span class="post-tag"><a class="btn btn-outline-warning">record</a></span>
            
        </div>

        <div class="post toc-header"><ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#what-is-recordwildcards">What is RecordWildCards?</a>
<ul>
<li><a href="#deconstruction">Deconstruction</a></li>
<li><a href="#construction">Construction</a></li>
</ul></li>
<li><a href="#implicit-scope">Implicit scope</a></li>
<li><a href="#strict-construction">Strict construction</a></li>
<li><a href="#compileless">Compileless</a></li>
<li><a href="#applicativedo">ApplicativeDo</a></li>
<li><a href="#duplicaterecordfields">DuplicateRecordFields</a></li>
<li><a href="#summary">Summary</a></li>
</ul></div>
        <div class="post"><h2 id="intro"><a href="#intro" class="anchor">Intro</a></h2>
<blockquote>
<p>With great power comes great responsibility!</p>
</blockquote>
<p>Record data types are vital for developing libraries and applications. However, there is a popular opinion that records in Haskell are not well-designed. The Haskell ecosystem has multiple approaches to deal with records pitfalls: a bunch of language extensions, multiple <code>lens</code> libraries, best-practices and naming conventions. But there is still no consensus on the best way to use records.</p>
<p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards">RecordWildCards</a> is one of the language extensions that improve the situation with records. However, it’s one of the most controversial extensions at the same time. Some people suggest avoiding this extension no matter what. Some prefer to use it everywhere. In this blog post, I’m going to review this extension under any possible angle and tell you when to use and when <em>not</em> to use it.</p>
<h2 id="what-is-recordwildcards"><a href="#what-is-recordwildcards" class="anchor">What is RecordWildCards?</a></h2>
<p>Let’s start with talking about how records are implemented in Haskell. When you define the following data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> name ::</span> <span class="dt">Text</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>In Haskell it’s actually syntax sugar for the following code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span> <span class="dt">Text</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">name ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>name (<span class="dt">User</span> n _) <span class="ot">=</span> n</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">age ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>age (<span class="dt">User</span> _ a) <span class="ot">=</span> a</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> in addition to generated functions each record also allows you to use record update syntax.</p>
</blockquote>
<p>As you can see, getter functions are generated with the same names and types as the corresponding fields. And you can operate with them as ordinary functions when you write code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">canBuyVodka ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>canBuyVodka user <span class="ot">=</span> age user <span class="op">&gt;=</span> <span class="dv">18</span></span></code></pre></div>
<h3 id="deconstruction"><a href="#deconstruction" class="anchor">Deconstruction</a></h3>
<p>The first feature that <code>RecordWildCards</code> allows you to do is to pattern-match on the constructor in a special way by bringing all its fields into scope not as functions but as values instead. So, using this extension we can rewrite code above in the following way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">canBuyVodka ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>canBuyVodka <span class="dt">User</span>{<span class="op">..</span>} <span class="ot">=</span> age <span class="op">&gt;=</span> <span class="dv">18</span></span></code></pre></div>
<p>In the snippet above <code>age</code> would be the value taken from <code>User</code> and it has type <code>Int</code>. It’s hard to see benefits in this small example. However, when you have a lot of fields and use them multiple times inside a single function, this extension becomes really handy.</p>
<h3 id="construction"><a href="#construction" class="anchor">Construction</a></h3>
<p>The second feature of <code>RecordWildCards</code> is the ability to construct values of the record type from identifiers in scope. Like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readUser ::</span> <span class="dt">IO</span> <span class="dt">User</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>readUser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    age  <span class="ot">&lt;-</span> <span class="fu">readLn</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="dt">User</span>{<span class="op">..</span>}</span></code></pre></div>
<p>Values <code>name</code> and <code>age</code> are used as corresponding fields of the <code>User</code> constructor. This helps to avoid code duplication and eliminates the need to come up with different variable names.</p>
<p>In the following sections, I’m going to highlight common concerns about this extension and recommend best-practices.</p>
<h2 id="implicit-scope"><a href="#implicit-scope" class="anchor">Implicit scope</a></h2>
<p>One of the reasons why some people don’t like <code>RecordWildCards</code> is because it’s not clear where the identifiers come from. Consider the following code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nameOnCard ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>nameOnCard <span class="dt">User</span>{<span class="op">..</span>} <span class="dt">Job</span>{<span class="op">..</span>} <span class="ot">=</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot; | &quot;</span> <span class="op">&lt;&gt;</span> title</span></code></pre></div>
<p>The problem with this code is that it’s not obvious from what data types these fields come from: is <code>name</code> a field of <code>User</code> or <code>Job</code>? Hard to tell without looking at the definitions of the corresponding types. This makes code hard to read and maintain.</p>
<p>One of the possible solutions some people recommend is to use the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-puns">NamedFieldPuns</a> extension. When this extension enabled, you can write the following code instead:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nameOnCard ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>nameOnCard <span class="dt">User</span>{name} <span class="dt">Job</span>{title} <span class="ot">=</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot; | &quot;</span> <span class="op">&lt;&gt;</span> title</span></code></pre></div>
<p><code>NamedFieldPuns</code> is similar to <code>RecordWildCards</code> but it forces you to specify explicitly what fields you are using. In this particular case, the extension solves the problem of figuring out where the variables come from, however, it has its own drawbacks:</p>
<ol type="1">
<li>When your records have a lot of fields and you use most of them, usage of this extension increases the size of your code significantly.</li>
<li>It introduces code duplication. You write field names twice: on the pattern-matching side and on the call side.</li>
</ol>
<p>Let’s see how all these problems can be solved with <code>RecordWildCards</code>. Because record fields are top-level functions and because there is no function overloading in Haskell, you can’t have two data types with the same field names in scope (though see the section about <a href="#duplicaterecordfields">DuplicateRecordFields</a>). One of the popular solutions to this difficulty is to prefix field names with the data type name or its abbreviation if the data type name is too long. Turns out that this approach also solves the above problem with <code>RecordWildCards</code>. This naming convention is so common that JSON and <code>lens</code> libraries provide options to strip prefixes automatically. If we define our data type like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> userName ::</span> <span class="dt">Text</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userAge  ::</span> <span class="dt">Int</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Then the function from our example becomes more readable!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nameOnCard ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>nameOnCard <span class="dt">User</span>{<span class="op">..</span>} <span class="dt">Job</span>{<span class="op">..</span>} <span class="ot">=</span> userName <span class="op">&lt;&gt;</span> <span class="st">&quot; | &quot;</span> <span class="op">&lt;&gt;</span> jobTitle</span></code></pre></div>
<p><strong>Conclusion:</strong> prefix field names with the type name to solve two problems at the same time.</p>
<h2 id="strict-construction"><a href="#strict-construction" class="anchor">Strict construction</a></h2>
<p>If you construct values using <code>RecordWildCards</code>, you might forget to specify all fields like in the code below:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">defaultUser ::</span> <span class="dt">User</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>defaultUser <span class="ot">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> userName <span class="ot">=</span> <span class="st">&quot;Ivan&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="dt">User</span>{<span class="op">..</span>}</span></code></pre></div>
<p>When GHC sees similar code, it outputs a warning that not all fields are initialised. But it’s very easy to miss this warning and get a runtime error later. The answer to this problem is to mark every field of your data type with the strict annotation:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> userName ::</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> userAge  ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> you can make all your types strict by default by enabling the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-data-types">StrictData</a> language extension.</p>
</blockquote>
<p>If you add <code>!</code> in front of each type, then all fields will become strict and you will see a compiler error instead of a warning when you forget to initialise some fields. Adding bangs is also considered one of the best-practices to avoid space leaks. It’s very rare wanting to have <em>lazy</em> fields of records.</p>
<blockquote>
<p><strong>NOTE:</strong> you can add <code>{-# OPTIONS_GHC -Werror=missing-fields #-}</code> to get a compile time error on unitialised lazy fields.</p>
</blockquote>
<p><strong>Conclusion:</strong> mark fields as strict to have more compile time checks and to avoid potential performance problems.</p>
<h2 id="compileless"><a href="#compileless" class="anchor">Compileless</a></h2>
<p>Another popular concern about <code>RecordWildCards</code> is that you lose compile time checks during pattern-matching when you add more fields. For example, we want to implement a <code>ToJSON</code> instance from the <a href="https://hackage.haskell.org/package/aeson">aeson</a> library for our <code>User</code> data type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    toJSON <span class="dt">User</span>{<span class="op">..</span>} <span class="ot">=</span> [<span class="st">&quot;name&quot;</span> <span class="op">.=</span> userName, <span class="st">&quot;age&quot;</span> <span class="op">.=</span> userAge]</span></code></pre></div>
<p>Now, if we add one more field to the <code>User</code> type, GHC wouldn’t warn us that we need to update this instance. If we want to see a compile time error we need to write this instance in a different way:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    toJSON (<span class="dt">User</span> name age) <span class="ot">=</span> [<span class="st">&quot;name&quot;</span> <span class="op">.=</span> name, <span class="st">&quot;age&quot;</span> <span class="op">.=</span> age]</span></code></pre></div>
<p>But let’s look at this problem closer. This is the case where we want to use <em>each</em> field of the constructor. However, not all functions are like that. In our <code>nameOnCard</code> function from the previous paragraph, we don’t want to use all fields, we’re interested only in a subset of them. And we don’t want to update that function when we change definitions of the <code>User</code> or <code>Job</code> types. However, in the <code>ToJSON</code> instance, we want to use <em>all</em> fields. So, the problem is not actually in <code>RecordWildCards</code>. We need to know where to apply this extension, though even here you can use <code>RecordWildCards</code> to make your life easier and here is why:</p>
<ol type="1">
<li>If you also define a <code>FromJSON</code> instance, you should implement roundtrip property-based tests to make sure that your <code>FromJSON</code> and <code>ToJSON</code> satisfy this property. It’s not possible to skip a <code>FromJSON</code> instance update because you will see a compile time error if you don’t initialise all fields of the type. Thus, if you forget to update <code>ToJSON</code> instance, you will observe a test failure.</li>
<li>If your <code>FromJSON/ToJSON</code> instances are trivial, you can use <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t:Generic">generics</a> or <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell">TemplateHaskell</a> to derive these instances automatically.</li>
<li>If your <code>ToJSON</code> instance is a part of your exposed API then you probably should care about not changing it accidentally. And for this, you need to provide golden tests.</li>
</ol>
<p>Forgetting to add a field is not the scariest problem actually. A scarier problem is that you can change the type of some field, your roundtrip tests are still passing, but consumers of your JSON API will observe errors. So <code>RecordWildCards</code> is not the most dangerous thing you should worry about here.</p>
<p>You <em>must</em> avoid <code>RecordWildCards</code> only when you really need compile time guarantees to use all fields of the type and when tests are not good. For example, when implementing binary serialisation. If you convert your data type to a sequence of 0s and 1s then failed test output won’t help you much to find where is the problem.</p>
<p><strong>Conclusion:</strong> not using <code>RecordWildCards</code> doesn’t help you to avoid <em>all</em> your problems, so implement tests to prevent your code from spontaneous breakages.</p>
<h2 id="applicativedo"><a href="#applicativedo" class="anchor">ApplicativeDo</a></h2>
<p>We talked about concerns with <code>RecordWildCards</code> but let’s talk about its advantages. Turns out that <code>RecorldWildCards</code> plays nicely with another language extension — <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#applicative-do-notation">ApplicativeDo</a>.</p>
<p>Let’s say we want to build CLI for a tool that allows to query some data and filter it by <code>from</code> and <code>to</code> entries. Terminal command for this tool may look like this:</p>
<pre><code>my-tool query --from 3 --to 42</code></pre>
<p>We can use <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> library to implement a parser for these options easily. Let’s start with creating our data type for the options:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Options</span> <span class="ot">=</span> <span class="dt">Options</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> optionsFrom ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> optionsTo   ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p><code>optparse-applicative</code> is built around <code>Applicative</code> functors. So in order to implement a parser for the <code>Options</code> data type you need to write code like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>fromP,<span class="ot"> toP ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">optionsP ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>optionsP <span class="ot">=</span> <span class="dt">Options</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> fromP</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> toP</span></code></pre></div>
<p>One problem with writing code in this style is that it’s very easy to use the wrong order of <code>fromP</code> and <code>toP</code> parsers when defining a parser for <code>Options</code> and this can lead to bugs. In a CLI you can write either <code>--from 3 --to 42</code> or <code>--to 42 --from 3</code> and both work correctly. But in code <code>Options &lt;$&gt; fromP &lt;*&gt; toP</code> is not the same as <code>Options &lt;$&gt; toP &lt;*&gt; fromP</code>. This semantic difference between real-world and expectations from code can lead to unexpected bugs.</p>
<p>This is true in general for such applicative-style code but it’s more important with regards to a CLI. Because it’s not that easy to test a CLI and to my knowledge, not many people really write automatic tests for their CLIs. So in this area of our code, we want to be more careful not to introduce extra bugs.</p>
<p>One of the solutions to the described problem is to introduce <code>newtype</code>s. But it might be too tedious to deal with lots of <code>newtype</code>s. Fortunately, we can use <code>RecordWildCards</code> and the <code>ApplicativeDo</code> extension to solve this problem easier!</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">optionsP ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>optionsP <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    optionsFrom <span class="ot">&lt;-</span> fromP</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    optionsTo   <span class="ot">&lt;-</span> toP</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="dt">Options</span>{<span class="op">..</span>}</span></code></pre></div>
<p>Now, even if you change the order of <code>optionsFrom</code> and <code>optionsTo</code> variables, the code still works.</p>
<p><strong>Conclusion:</strong> <code>RecordWildCards</code> combined with <code>ApplicativeDo</code> allows you to write type-safe and maintainable code.</p>
<h2 id="duplicaterecordfields"><a href="#duplicaterecordfields" class="anchor">DuplicateRecordFields</a></h2>
<p>Due to the records implementation details, it’s not possible to have data types with the same field names in scope in standard Haskell code (as per Haskell2010). However, if you enable the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields">DuplicateRecordFields</a> extension, it becomes possible. You can leverage this extension to convert between data types easily:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Man</span> <span class="ot">=</span> <span class="dt">Man</span> {<span class="ot"> name ::</span> <span class="op">!</span><span class="dt">Text</span> }</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cat</span> <span class="ot">=</span> <span class="dt">Cat</span> {<span class="ot"> name ::</span> <span class="op">!</span><span class="dt">Text</span> }</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">evilMagic ::</span> <span class="dt">Man</span> <span class="ot">-&gt;</span> <span class="dt">Cat</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>evilMagic <span class="dt">Man</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="dt">Cat</span>{<span class="op">..</span>}</span></code></pre></div>
<p>However, such automatic conversion works only if fields of different types have the <em>exact</em> same names. So, if data types have different prefixes, you need to write a mapping between fields explicitly. But if you decide not to add prefixes for the field names, some pieces of your code that do something else besides mere conversion between data types, can become less readable if you use <code>RecordWildCards</code> in them.</p>
<p><strong>Conclusion:</strong> if you convert between data types more often than you use them, you can leverage the combination of <code>RecordWildCards</code> and <code>DuplicateRecordFields</code> extensions.</p>
<h2 id="summary"><a href="#summary" class="anchor">Summary</a></h2>
<p><code>RecordWildCards</code> is a very useful and convenient extension. It can be used in the wrong way. However, if you follow best-practices, this extension can become your best friend in writing elegant and maintainable code.</p></div>
    </section>

  </div>

  <!-- Bootstrap core JavaScript -->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"> </script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.0/js/bootstrap.bundle.min.js" integrity="sha384-VoPFvGr9GxhDT3n8vqqZ46twP5lgex+raTCfICQy73NLhN7ZqSfCtfSn4mLA2EFA" crossorigin="anonymous"></script>
  <!-- Plugin JavaScript -->

  <script src="./js/jquery.easing.min.js"></script>
  <!-- Code highlighting  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
  <script>hljs.initHighlightingOnLoad()</script>

  <!-- Custom scripts for this template -->
  <script src="./js/resume.min.js"></script>

</body>

</html>
